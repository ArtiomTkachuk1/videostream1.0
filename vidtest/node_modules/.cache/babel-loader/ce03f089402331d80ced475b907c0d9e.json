{"ast":null,"code":"var _jsxFileName = \"C:\\\\\\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\\\\\u043A\\u043E\\u0434\\\\videostream1.0\\\\vidtest\\\\src\\\\components\\\\VideoTag\\\\VideoTagv1.js\";\nimport React from 'react';\nvar sourceBuffer = null;\nexport default class VideoTag extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.processStream = data => {\n      if (data.done) {\n        return;\n      } // append chunk of stream to `sourceBuffer`\n\n\n      sourceBuffer.appendBuffer(data.value);\n    };\n\n    this.sourceOpen = event => {\n      // if the media type is supported by `mediaSource`\n      // fetch resource, begin stream read,\n      // append stream to `sourceBuffer`\n      sourceBuffer = this.MediaSource.addSourceBuffer(this.mimecodec); // set `sourceBuffer` `.mode` to `\"sequence\"`\n\n      sourceBuffer.mode = \"sequence\";\n      fetch(\"http://localhost:3000/video/1\") // return `ReadableStream` of `response`\n      .then(response => response.body.getReader()).then(reader => {\n        this.processStream(response.data); // at `sourceBuffer` `updateend` call `reader.read()`,\n        // to read next chunk of stream, append chunk to\n        // `sourceBuffer`\n\n        sourceBuffer.addEventListener(\"updateend\", updateend = () => {\n          reader.read().then(this.processStream(data));\n        }); // start processing stream\n\n        reader.read().then(this.processStream(data)); // do stuff `reader` is closed,\n        // read of stream is complete\n\n        return reader.closed.then(() => {\n          // signal end of stream to `mediaSource`\n          this.MediaSource.endOfStream();\n          return this.MediaSource.readyState;\n        });\n      }) // do stuff when `reader.closed`, `mediaSource` stream ended\n      .then(msg => console.log(msg));\n    };\n\n    this.MediaSource = new MediaSource();\n    this.src = URL.createObjectURL(this.MediaSource);\n    this.MediaSource.addEventListener('sourceopen', this.sourceOpen, {\n      once: true\n    });\n    this.mimecodec = 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"';\n  }\n\n  /*sourceOpen=()=>{\r\n    URL.revokeObjectURL(this.src);\r\n    const sourceBuffer = this.mediaSource.addSourceBuffer('video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"');\r\n    fetch('http://localhost:3000/video/1')//, { headers: { range: 'bytes=0-567139' } })\r\n      .then(response => response.arrayBuffer())\r\n        .then(data => {\r\n          sourceBuffer.appendBuffer(data);\r\n          sourceBuffer.addEventListener('updateend', this.updateEnd, { once: true });\r\n        });\r\n  }\r\n  fetchNextSegment=()=>{\r\n    fetch('http://localhost:3000/video/2')//, { headers: { range: 'bytes=567140-1196488' } })\r\n    .then(response => response.arrayBuffer())\r\n    .then(data => {\r\n      const sourceBuffer = this.mediaSource.sourceBuffers[0];\r\n      sourceBuffer.appendBuffer(data);\r\n      // TODO: Fetch further segment and append it.\r\n    });\r\n  }*/\n  render() {\n    return React.createElement(React.Fragment, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 75\n      },\n      __self: this\n    }, \"Videotag\", React.createElement(\"video\", {\n      src: this.src,\n      onPlaying: this.fetchNextSegment,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 77\n      },\n      __self: this\n    }));\n  }\n\n}","map":{"version":3,"sources":["C:/работа/код/videostream1.0/vidtest/src/components/VideoTag/VideoTagv1.js"],"names":["React","sourceBuffer","VideoTag","Component","constructor","props","processStream","data","done","appendBuffer","value","sourceOpen","event","MediaSource","addSourceBuffer","mimecodec","mode","fetch","then","response","body","getReader","reader","addEventListener","updateend","read","closed","endOfStream","readyState","msg","console","log","src","URL","createObjectURL","once","render","fetchNextSegment"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AAEA,IAAIC,YAAY,GAAC,IAAjB;AAEA,eAAe,MAAMC,QAAN,SAAuBF,KAAK,CAACG,SAA7B,CAAuC;AACpDC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,UAAMA,KAAN;;AADiB,SAQnBC,aARmB,GAQFC,IAAD,IAAU;AACtB,UAAIA,IAAI,CAACC,IAAT,EAAe;AACb;AACD,OAHqB,CAItB;;;AACAP,MAAAA,YAAY,CAACQ,YAAb,CAA0BF,IAAI,CAACG,KAA/B;AACD,KAdgB;;AAAA,SAenBC,UAfmB,GAePC,KAAD,IAAS;AAChB;AACA;AACA;AACAX,MAAAA,YAAY,GAAG,KAAKY,WAAL,CAAiBC,eAAjB,CAAiC,KAAKC,SAAtC,CAAf,CAJgB,CAKhB;;AACAd,MAAAA,YAAY,CAACe,IAAb,GAAoB,UAApB;AAEAC,MAAAA,KAAK,CAAC,+BAAD,CAAL,CACE;AADF,OAEGC,IAFH,CAEQC,QAAQ,IAAIA,QAAQ,CAACC,IAAT,CAAcC,SAAd,EAFpB,EAGGH,IAHH,CAGQI,MAAM,IAAI;AAEd,aAAKhB,aAAL,CAAmBa,QAAQ,CAACZ,IAA5B,EAFc,CAGZ;AACA;AACA;;AACFN,QAAAA,YAAY,CAACsB,gBAAb,CAA8B,WAA9B,EAA2CC,SAAS,GAAC,MAAI;AACvDF,UAAAA,MAAM,CAACG,IAAP,GAAcP,IAAd,CAAmB,KAAKZ,aAAL,CAAmBC,IAAnB,CAAnB;AACD,SAFD,EANc,CASd;;AACAe,QAAAA,MAAM,CAACG,IAAP,GAAcP,IAAd,CAAmB,KAAKZ,aAAL,CAAmBC,IAAnB,CAAnB,EAVc,CAWd;AACA;;AACA,eAAOe,MAAM,CAACI,MAAP,CAAcR,IAAd,CAAmB,MAAM;AAC9B;AACA,eAAKL,WAAL,CAAiBc,WAAjB;AACA,iBAAO,KAAKd,WAAL,CAAiBe,UAAxB;AACD,SAJM,CAAP;AAKD,OArBH,EAsBE;AAtBF,OAuBGV,IAvBH,CAuBQW,GAAG,IAAIC,OAAO,CAACC,GAAR,CAAYF,GAAZ,CAvBf;AAwBD,KA/CgB;;AAEjB,SAAKhB,WAAL,GAAmB,IAAIA,WAAJ,EAAnB;AACA,SAAKmB,GAAL,GAASC,GAAG,CAACC,eAAJ,CAAoB,KAAKrB,WAAzB,CAAT;AACA,SAAKA,WAAL,CAAiBU,gBAAjB,CAAkC,YAAlC,EAAgD,KAAKZ,UAArD,EAAiE;AAAEwB,MAAAA,IAAI,EAAE;AAAR,KAAjE;AACA,SAAKpB,SAAL,GAAiB,4CAAjB;AAED;;AAyCD;;;;;;;;;;;;;;;;;;;AAmBAqB,EAAAA,MAAM,GAAE;AACN,WACE,oBAAC,KAAD,CAAO,QAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAEE;AACE,MAAA,GAAG,EAAE,KAAKJ,GADZ;AAEE,MAAA,SAAS,EAAE,KAAKK,gBAFlB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAFF,CADF;AASD;;AA9EmD","sourcesContent":["import React from 'react'\r\n\r\nvar sourceBuffer=null;\r\n\r\nexport default class VideoTag extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.MediaSource = new MediaSource();\r\n    this.src=URL.createObjectURL(this.MediaSource);\r\n    this.MediaSource.addEventListener('sourceopen', this.sourceOpen, { once: true });\r\n    this.mimecodec = 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"';\r\n\r\n  }\r\n  processStream = (data) => {\r\n      if (data.done) {\r\n        return;\r\n      }\r\n      // append chunk of stream to `sourceBuffer`\r\n      sourceBuffer.appendBuffer(data.value);\r\n    }\r\n  sourceOpen=(event)=>{\r\n      // if the media type is supported by `mediaSource`\r\n      // fetch resource, begin stream read,\r\n      // append stream to `sourceBuffer`\r\n      sourceBuffer = this.MediaSource.addSourceBuffer(this.mimecodec);\r\n      // set `sourceBuffer` `.mode` to `\"sequence\"`\r\n      sourceBuffer.mode = \"sequence\";\r\n\r\n      fetch(\"http://localhost:3000/video/1\")\r\n        // return `ReadableStream` of `response`\r\n        .then(response => response.body.getReader())\r\n        .then(reader => {\r\n\r\n          this.processStream(response.data);\r\n            // at `sourceBuffer` `updateend` call `reader.read()`,\r\n            // to read next chunk of stream, append chunk to\r\n            // `sourceBuffer`\r\n          sourceBuffer.addEventListener(\"updateend\", updateend=()=>{\r\n            reader.read().then(this.processStream(data));\r\n          });\r\n          // start processing stream\r\n          reader.read().then(this.processStream(data));\r\n          // do stuff `reader` is closed,\r\n          // read of stream is complete\r\n          return reader.closed.then(() => {\r\n            // signal end of stream to `mediaSource`\r\n            this.MediaSource.endOfStream();\r\n            return this.MediaSource.readyState;\r\n          })\r\n        })\r\n        // do stuff when `reader.closed`, `mediaSource` stream ended\r\n        .then(msg => console.log(msg))\r\n    };\r\n  /*sourceOpen=()=>{\r\n    URL.revokeObjectURL(this.src);\r\n    const sourceBuffer = this.mediaSource.addSourceBuffer('video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"');\r\n    fetch('http://localhost:3000/video/1')//, { headers: { range: 'bytes=0-567139' } })\r\n      .then(response => response.arrayBuffer())\r\n        .then(data => {\r\n          sourceBuffer.appendBuffer(data);\r\n          sourceBuffer.addEventListener('updateend', this.updateEnd, { once: true });\r\n        });\r\n  }\r\n  fetchNextSegment=()=>{\r\n    fetch('http://localhost:3000/video/2')//, { headers: { range: 'bytes=567140-1196488' } })\r\n    .then(response => response.arrayBuffer())\r\n    .then(data => {\r\n      const sourceBuffer = this.mediaSource.sourceBuffers[0];\r\n      sourceBuffer.appendBuffer(data);\r\n      // TODO: Fetch further segment and append it.\r\n    });\r\n  }*/\r\n  render(){\r\n    return (\r\n      <React.Fragment>\r\n        Videotag\r\n        <video\r\n          src={this.src}\r\n          onPlaying={this.fetchNextSegment}\r\n        />\r\n      </React.Fragment>\r\n    )\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}